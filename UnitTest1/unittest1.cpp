#include "stdafx.h"
#include "CppUnitTest.h"
#include "ComputePi.h"
using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace UnitTest1
{		
	TEST_CLASS(UnitTest1)
	{
	public:
		TEST_METHOD(LargeDecimalfromStr)
		{
			string a1 = "123456789";
			int length = (int)a1.length();
			char a2[] = { 9, 8, 7, 6, 5, 4, 3, 2, 1 };

			LargeDecimal ld1(a1);
			Assert::AreEqual(length, ld1.ndigits);
			for (int i = 0; i < length; i++)
			{
				Assert::AreEqual(a2[i], ld1.digits[i]);
			}

		}

		TEST_METHOD(LargeDecimaltoStr)
		{
			string a1 = "123456789";
			int length = (int)a1.length();
			char a2[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

			LargeDecimal ld1(a1);
			Assert::AreEqual(a1, ld1.tostr());
		}

		TEST_METHOD(LargeUIntPlus1)
		{
			uint64_t a1[] = { 0xffffffffffffffff, 2 };
			uint64_t a2[] = { 1, 0xffffffffffffffff, };
			uint64_t a3[] = { 0, 2, 1 };
			int len1 = 2;
			int len2 = 2;
			int len3 = 3;


			LargeUInt64 lui1(a1, len1);
			LargeUInt64 lui2(a2, len2);

			LargeUInt64 lui3 = lui1 + lui2;
			Assert::AreEqual(len3, lui3.ndigits);
			for (int i = 0; i < len3; i++)
			{
				Assert::AreEqual(a3[i], lui3.digits[i]);
			}


		}

		TEST_METHOD(LargeUIntMinus1)
		{
			uint64_t a1[] = { 0, 2, 2 };
			uint64_t a2[] = { 0xffffffffffffffff, 2, 1 };
			uint64_t a3[] = { 1, 0xffffffffffffffff, };
			
			int len1 = 3;
			int len2 = 3;
			int len3 = 2;


			LargeUInt64 lui1(a1, len1);
			LargeUInt64 lui2(a2, len2);

			LargeUInt64 lui3 = lui1 - lui2;
			Assert::AreEqual(len3, lui3.ndigits);
			for (int i = 0; i < len3; i++)
			{
				Assert::AreEqual(a3[i], lui3.digits[i]);
			}

		}
		
		TEST_METHOD(LargeUIntMulti1)
		{
			uint64_t a1[] = { 0xfffffffffffffffd, 0x2, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
			uint64_t a2[] = { 0x3, 0xffe };
			uint64_t a3[] = { 0xfffffffffffffff7, 0xffffffffffffd00e, 0x3002, 0x2ffa };

			int len1 = 9;
			int len2 = 2;
			int len3 = 4;



			LargeUInt64 lui1(a1, len1);
			LargeUInt64 lui2(a2, len2);

			LargeUInt64 lui3 = lui1 * lui2;
			Assert::AreEqual(len3, lui3.ndigits);
			for (int i = 0; i < len3; i++)
			{
				Assert::AreEqual(a3[i], lui3.digits[i]);
			}

		}

		TEST_METHOD(LargeUIntPower1)
		{
			uint64_t base = 0xdf;
			int exp = 10;
			uint64_t a3[] = { 0x84494d3680de6b41, 0x4066 };

			int len3 = 2;


			LargeUInt64 lui3 = power(base, exp);
			Assert::AreEqual(len3, lui3.ndigits);
			for (int i = 0; i < len3; i++)
			{
				Assert::AreEqual(a3[i], lui3.digits[i]);
			}

		}

		TEST_METHOD(LargeUIntPlus2)
		{

			string a1 = "1212321332423423442114221";
			string a2 = "3284732987329872387121414";

			string a3 = "4497054319753295829235635";

			LargeDecimal ld1(a1);
			LargeDecimal ld2(a2);
			LargeUInt64 lui1(ld1);
			LargeUInt64 lui2(ld2);
			LargeUInt64 lui3 = lui1 + lui2;
			string ans = lui3.Conv2Dec();

			Assert::AreEqual(a3, ans);
		}

		TEST_METHOD(LargeUIntConvertfromdec)
		{

			string a1 = "1020847100762815390445464054516433289213";
			uint64_t a2[] = { 0xfffffffffffffffd, 0x2, 0x3 };
			int len2 = 3;
			
			LargeDecimal ld1(a1);

			LargeUInt64 lui1(ld1);

			Assert::AreEqual(len2, lui1.ndigits);
			for (int i = 0; i < len2; i++)
			{
				Assert::AreEqual(a2[i], lui1.digits[i]);
			}
		}

		TEST_METHOD(LargeUInt64ContoDec)
		{

			string a1 = "1020847100762815390445464054516433289213";
			uint64_t a2[] = { 0xfffffffffffffffd, 0x2, 0x3 };
			int len2 = 3;

			LargeUInt64 lui2(a2, len2);
			string c = lui2.Conv2Dec();
			LargeDecimal ld1(c);
			Assert::AreEqual(a1, ld1.tostr());
		}

		TEST_METHOD(BigFloatInverseSquareRoot)
		{
			double a1 = 3;
			string s1 = "5773502691896257645091487805019574556476017512701268760186023264839776723029333456937153955857495252252087138051355676766566483649996508262705518373647912161760310773007685273559916067003615583077550051041144223011076288835574182229739459904090157105534559538626730166621791266197964892167825021920169188727827098687003158673957301083610486098413199443325966081694295714879443057824080546615292851325559860212727845553702810579269647927720340294351749672233411735703814295653303187885990290561660242998310988280943402621362013295795658458607724392771319976610026129009590179711231877707012357546730830355894103997627918803804740055809173674576647569436866328198253292214296325987159459861300762849509678586779509360214606574482203532299076242884213846075548994733403984947184261470604288448356783972166722297648051602820237590479999209756115431924794539650367090495462489921819941505961836584596712935549873039874076523701850809745743973992460875205438229473442845722276462165373056832462787984986460";
			BigFloat bf = InverseSquareRoot(a1, 1000);
			string s = bf.ftostr(1000);
			Assert::AreEqual(s1, s);

			double a2 = 17;
			string s2 = "2425356250363329735189064621161221779498352485513894373175666807702914321375071525639919794594520174520320024081890671538412600494362275507693851850439357045692366627315435801816347392689638651897365518077978284623711260441061571713840777734105128334009292044650635626762925823980424343346595356887600605297364861751174839875565528976426230219497445776032202130810136773990043176860280524388761760773001433105554933106207433808859355929923092636867884563280545567430391971195939304189952867174037901159443944681462191724672708012150622442713873556722392865970625944067189627954260874551328262963394867646215630128570842411943295650886168914523940165615792035037943201088194469199711222717622966667181048845136744767648460768002146234053833963603029250059643115076774692585974196755120012629146774872808691251960051044372046648214414034674098668542327660209694878131313160642147085150417329509248087731279733794778069624491363230868014155997388248679961411072035559716837615158477719320307898684856419";
			bf = InverseSquareRoot(a2, 1000);
			s = bf.ftostr(1000);
			Assert::AreEqual(s2, s);
		}


		TEST_METHOD(BigFloatReciprocal)
		{
			uint64_t u[] = { 3 };
			string s0 = "3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333";
			LargeUInt64 denom(u, 1);
			BigFloat bf = Reciprocal(BigFloat(denom, (1000 / 19 + 2)), 1000);
			string s1 = bf.ftostr(1000);
			Assert::AreEqual(s0, s1);


		}
		
	};
}